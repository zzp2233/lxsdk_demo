/*
Copyright (c) 2017 Silan MEMS. All Rights Reserved.
*/

#ifndef SL_WATCH_APPLICATION__H__
#define SL_WATCH_APPLICATION__H__

#include "include.h"

#if  (SENSOR_STEP_SEL == SENSOR_STEP_SC7A20)

#define SC7A20_WRITE_ADDR(ADDR)         ((ADDR) << 1)
#define SC7A20_READ_ADDR_UPDATE(ADDR)   ((ADDR) << 1 | 1)
#define SC7A20_READ_ADDR(ADDR)          ((ADDR) << 1 | 1) << 8 | ((ADDR) << 1)

#define SL_Sensor_Algo_Release_Enable 0x01
//0x00: for debug
//0x01: release version

/***使用驱动前请根据实际接线情况配置******/
/**SC7A20的SDO 脚接地：  0****************/
/**SC7A20的SDO 脚接电源：1****************/
#define SL_SC7A20_SDO_VDD_GND            0
/*****************************************/

/***使用驱动前请根据实际IIC情况进行配置***/
/**SC7A20的IIC 接口地址类型 7bits：  0****/
/**SC7A20的IIC 接口地址类型 8bits：  1****/
#define SL_SC7A20_IIC_7BITS_8BITS        0
/*****************************************/

#if SL_SC7A20_SDO_VDD_GND==0
#define SL_SC7A20_IIC_7BITS_ADDR        0x18
#define SL_SC7A20_IIC_8BITS_WRITE_ADDR  0x30
#define SL_SC7A20_IIC_8BITS_READ_ADDR   0x31
#else
#define SL_SC7A20_IIC_7BITS_ADDR        0x19
#define SL_SC7A20_IIC_8BITS_WRITE_ADDR  0x32
#define SL_SC7A20_IIC_8BITS_READ_ADDR   0x33
#endif

#if SL_SC7A20_IIC_7BITS_8BITS==0
#define SL_SC7A20_IIC_ADDRESS        SL_SC7A20_IIC_7BITS_ADDR
#else
#define SL_SC7A20_IIC_WRITE_ADDRESS  SL_SC7A20_IIC_8BITS_WRITE_ADDR
#define SL_SC7A20_IIC_READ_ADDRESS   SL_SC7A20_IIC_8BITS_READ_ADDR
#endif

#define SL_SC7A20_CHIP_ID_ADDR       (unsigned char)0x0F
#define SL_SC7A20_CHIP_ID_VALUE      (unsigned char)0x11
#define SL_SC7A20_VERSION_ADDR       (unsigned char)0x70
#define SL_SC7A20_VERSION_VALUE      (unsigned char)0x11
#define SL_SC7A20E_VERSION_VALUE     (unsigned char)0x26
#define SL_SC7A20H_VERSION_VALUE     (unsigned char)0x28

extern  unsigned int  SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_SWAY_ALGO(void);
extern  signed char SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_SWAY_INIT(void);
extern  signed int  SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_INT_SWAY_ALGO(void);
extern  unsigned char SL_MCU_SLEEP_ALGO_FUNCTION(void);
// extern  void sl_update_sleep_sys_hour(unsigned char hour);

/********客户需要进行的IIC接口封包函数****************/
extern unsigned char SL_SC7A20_I2cAddr_Read(unsigned char iic_addr, unsigned char reg, unsigned char len, unsigned char *buf);
/***SL_SC7A20_I2cAddr_Read 函数中， iic_addr:Sensor's i2c address Reg：寄存器地址  len:读取数据长度，buf:存储数据首地址（指针）***/
/***SL_SC7A20_I2cAddr_Read 函数 是可以进行单次读或多次连续读取的函数**************************************************************/

/********客户用于对传感器的IIC地址查找函数************************/
unsigned char SL_ACC_Find_I2C_Address(void);
/****返回值7位地址：0x18-0x1F   通讯正常，按照该地址进行应用******/
/****返回值7位地址：0x00        通讯异常，检测芯片或焊接问题******/

/********客户需要进行的IIC&SPI接口封包函数************************/
extern unsigned char SL_SC7A20_I2c_Spi_Write(bool sl_spi_iic,unsigned char reg, unsigned char dat);
extern unsigned char SL_SC7A20_I2c_Spi_Read(bool sl_spi_iic,unsigned char reg, unsigned char len, unsigned char *buf);
/**SL_SC7A20_I2c_Spi_Write 函数中， sl_spi_iic:0=spi  1=i2c  Reg：寄存器地址   dat：寄存器的配置值*******************/
/**SL_SC7A20_I2c_Spi_Write 函数 是一个单次写的函数*******************************************************************/
/***SL_SC7A20_I2c_Spi_Read 函数中， sl_spi_iic:0=spi  1=i2c Reg 同上，len:读取数据长度，buf:存储数据首地址（指针）***/
/***SL_SC7A20_I2c_Spi_Read 函数 是可以进行单次读或多次连续读取的函数*************************************************/

/*************驱动初始化函数**************/
signed char SL_SC7A20_Driver_Init(bool Sl_spi_iic_init,unsigned char Sl_pull_up_mode,bool sl_addr_auto);
/***输入参数:1,Sl_spi_iic_init:0-1***2,PULL_UP_MODE:0x00 0x08 0x04 0x0c********/
/****Sl_spi_iic_init=0：SPI MODE, Sl_pull_up_mode config failed****************/
/****Sl_spi_iic_init=1：IIC MODE***********************************************/
/****Sl_pull_up_mode=0x00: SDO  I2C  pull up***********************************/
/****Sl_pull_up_mode=0x08: I2C  pull up and  SDO  open drain*******************/
/****Sl_pull_up_mode=0x04: SDO  pull up and  I2C  open drain*******************/
/****Sl_pull_up_mode=0x0C: SDO  I2C  open drain********************************/
/****sl_addr_auto=0: 地址不自增，仅对SC7A20E有效，应用于单地址读取FIFO数据*****/
/****sl_addr_auto=1: 地址自增，仅对SC7A20E有效，应用于多地址读取FIFO数据*******/
/****SDO脚接地，推荐关闭SDO内部上拉电阻****************************************/
/****SPI通讯，推荐关闭SDA，SCL内部上拉电阻，SDO内部上拉电阻会自动关闭**********/
/****SC7A20E/SC7A20ET，推荐sl_addr_auto=0，单地址读取可以节约I2C通讯时的功耗***/

/*************返回数据情况如下*****************/
/**return : 0x11 SC7A20表示CHIP ID 正常********/
/**return : 0x26 SC7A20E表示CHIP ID 正常*******/
/**return : 0x28 SC7A20H表示CHIP ID 正常*******/
/**return : 0         表示读取异常*************/
/**return :-1;        SPI 通信问题*************/
/**return :-2;        IIC 通信问题*************/
/**return :-3;        连续读取 通信问题********/


/************获取FIFO全数据必须调用函数********/
void SL_SC7A20_All_FIFO_Read_SET(void);
/************执行其他算法是必须不能调用********/
/**每次执行SL_SC7A20_Read_FIFO之前调用*********/
/**调用步骤1：SL_SC7A20_All_FIFO_Read_SET******/
/**调用步骤2：SL_SC7A20_Read_FIFO**************/
/**调用步骤3：SL_SC7A20_GET_FIFO_Buf***********/
/**整个循环周期：建议先判断FIFO是否已满********/


/***************执行算法前需要读取FIFO数据*****/
/***************FIFO数据读取后，FIFO会清空*****/
/***************所以FIFO只能定时读取一次*******/
unsigned char SL_SC7A20_Read_FIFO(void);
/**return : FIFO_LEN    表示数组长度***********/


/****说明:该函数需要定时执行,从而保证算法执行到位**/
/***************执行算法获取计步结果***************/
unsigned int SL_Watch_Kcal_Pedo_Algo(bool sl_music_motor_en);
/***sl_music_motor_en=0: 马达电机和音乐功能未打开**/
/***sl_music_motor_en=1: 马达电机和音乐功能已打开**/
/**************获取当天的当前计步值****************/
/*************输出数据为：计步值(步)***************/

/***************获取三轴原始数据***************/
unsigned char SL_SC7A20_GET_FIFO_Buf(signed short *sl_x_buf,signed short *sl_y_buf,signed short *sl_z_buf,bool filter_en);
/****************执行算法后执行该命令**********/
/**x_buf  y_buf  z_buf : 长度32的数组首地址****/
/**filter_en：0 低通滤波禁止 1：低通滤波使能***/
/****************返回数据情况如下**************/
/**return : FIFO_LEN    表示数组长度***********/

/***************获取三轴实时数据***************/
void SL_SC7A20_GET_DATA(signed short *sl_x_dat,signed short *sl_y_dat,signed short *sl_z_dat);
/***SC7A20/SC7A20T:    获取上一次读取FIFO的最后一组数据*********/
/***SC7A20E/SC7A20ET:  获取实时数据，且不对FIFO数据产生影响*****/

/******************复位计步值************************/
void SL_Pedo_Kcal_ResetStepCount(void);
/**********输入数据为：无******输出数据为：无********/
/*使用方法: 系统时间到第二天时，调用该函数清除计步值*/

/*******************计步状态复位**********************/
void SL_Pedo_WorkMode_Reset(void);
/******************输入参数：无***********************/
/******************输出值参数：无*********************/

/******************升级后，设置计步值,距离,热量************************/
/******************升级后，请在初始化函数后，增加该函数****************/
void SL_Pedo_StepCount_Set(unsigned int sl_pedo_value,unsigned int sl_dis_value,unsigned int sl_kcal_value);
/**********输入数据为：sl_pedo_value  计步值*****/
/**********输入数据为：sl_dis_value   距离值*****/
/**********输入数据为：sl_kcal_value  热量值*****/

/******************计步灵敏度设置********************/
void SL_PEDO_TH_SET(unsigned char sl_pedo_amp,unsigned char sl_pedo_th,unsigned char sl_pedo_weak,unsigned char sl_zcr_lel,unsigned char sl_scope_lel);
/******sl_pedo_amp>4&&sl_pedo_amp<201**************************/
/******sl_pedo_amp:越小灵敏度越高，越容易计步******************/
/******sl_pedo_amp:越大灵敏度越高，越难计步********************/
/******sl_pedo_amp:默认值26，不设置就是26**********************/

/******sl_pedo_th>5&&sl_pedo_th<50*****************************/
/******sl_pedo_th:越小灵敏度越高，越容易计步*******************/
/******sl_pedo_th:越大灵敏度越高，越难计步*********************/
/******sl_pedo_th:默认值10，不设置就是10***********************/

/******sl_pedo_weak>=0&&sl_pedo_weak<6*************************/
/******sl_pedo_weak:0,不打开轻微走路计步功能*********************/
/******sl_pedo_weak:1,打开轻微走路计步功能***********************/
/******sl_pedo_weak:2,打开轻微走路计步功能***********************/
/******sl_pedo_weak:3,打开轻微走路计步功能***********************/
/******sl_pedo_weak:4,打开轻微走路计步功能***********************/
/******sl_pedo_weak:5,打开轻微走路计步功能***********************/
/******sl_pedo_weak:默认值0,设置的值越大，检测计步的越灵敏*******/

/*****sl_zcr_lel>=0&&sl_zcr_lel<=255***************************/
/*****sl_zcr_lel:默认值=20,设置的值越小，越容易屏蔽喇叭震动****/
/*****一定时间内的过零率计算***********************************/

/*****sl_scope_lel>=0&&sl_scope_lel<=255***********************/
/*****整体数据幅度阈值*****************************************/


/*******计步主轴设置****************/
void SL_PEDO_SET_AXIS(unsigned char sl_xyz);
/***sl_xyz:0  x轴*******************/
/***sl_xyz:1  y轴*******************/
/***sl_xyz:2  z轴*******************/
/***sl_xyz:3  算法决定**************/

/*设置运动检测幅度阈值和时间阈值****/
void SL_PEDO_INT_SET(unsigned char V_TH,unsigned char T_TH,bool INT_EN);
/***V_TH:0  0-127************************************/
/***T_TH:1  0-127************************************/
/***INT_EN:0 关闭中断功能，1，打开中断状态监测功能***/
/***USE AOI2 INT*************************************/

/*设置运动状态读取******************/
bool SL_INT_STATUS_READ(void);
/*0：  没有运动*********************/
/*1：  有运动***********************/
/*关闭中断功能情况下，一直输出1*****/

/***********关闭IIC设备**************/
/***********Power down 函数**********/
/********不使用该设备情况下**********/
/****如需重启，使用驱动初始化函数****/
bool  SL_SC7A20_Power_Down(void);
/*************输入参数:无************/
/**********返回参数情况说明**********/
/**return  1: Power Down Success*****/
/**return  0: Power Down Fail********/


/*********传感器的工作频率设置***********/
void SC7A20_ODR_SET(unsigned char sl_odr);//10 50/25
/**sl_odr:0 10Hz(SC7A20E/SC7A20H) 25Hz(SC7A20)***********/
/**sl_odr:1 50Hz(SC7A20/SC7A20E/SC7A20H Lower-Power)*****/
/**sl_odr:2 50Hz(SC7A20E/SC7A20/SC7A20H HP-Mode)*********/



/*************初始化个人参数*************/
/**参数初始化，用于热量，距离计算********/
void SL_Pedo_Person_Inf_Init(unsigned char *Person_Inf_Init);
/*********输入指针参数分别是:身高 体重 年龄 性别***举例:178,60,26 1*********/
/**身高范围:  30cm ~ 250cm  ***********/
/**体重范围:  10Kg ~ 200Kg  ***********/
/**年龄范围:  3岁  ~ 150岁  ***********/
/**性别范围:  0 ~ 1    0:女 1:男   ****/

/*********************获取运动状态值**********************/
unsigned char SL_Pedo_GetMotion_Status(void);
/**********输入数据为：无*********************************/
/**********输出数据为：0 ~ 3 *****************************/
/**输出数据为：0   *静止或静坐**********/
/**输出数据为：1   *慢走或散步**********/
/**输出数据为：2   *正常走路************/
/**输出数据为：3   *跑步或剧烈运动******/

/**************获取截止当前当天的行走距离*****************/
unsigned int SL_Pedo_Step_Get_Distance(void);
/*******************输入数据为：无************************/
/*******************输出数据为：当天行走距离 *************/
/*******************单位:       分米(dm)******************/

/**************获取截止当前当天的热量消耗*****************/
unsigned int SL_Pedo_Step_Get_KCal(void);
/*******************输入数据为：无************************/
/*******************输出数据为：当天热量消耗值 ***********/
/*********单位: 大卡     1个单位=0.1大卡******************/

/**************获取最近一段时间的走路平均幅度*************/
unsigned short SL_Pedo_Step_Get_Avg_Amp(void);
/********************输入数据为：无***********************/
/***********************1LSB≈XXXmg************************/

/***********************获取当前走路平均步频**************/
unsigned char SL_Pedo_Step_Get_Step_Per_Min(void);
/********************输入数据为：无***********************/
/********************输出数据为：XXX步/分钟 **************/

/***********************获取当前的运动等级****************/
unsigned char SL_Pedo_Step_Get_Motion_Degree(void);
/********************输入数据为：无***********************/
/********************输出数据为：0-25 ********************/


/**********抬手亮屏算法**********/

/*****************抬手亮屏算法初始化函数****************/
void SL_Turn_Wrist_Init(unsigned char *SL_Turn_Wrist_Para);
/************输入参数：*************/
/******SL_Turn_Wrist_Para[0]:加速度计贴片位置设置  0--7********/
/******SL_Turn_Wrist_Para[1]:抬手亮屏灵敏度设置    1--5********/
/******SL_Turn_Wrist_Para[2]:水平抬手亮屏使能控制位0--1********/

/*************三轴加速度计贴片位置设置*************************/
/***SL_Turn_Wrist_Para[0]：设定值的范围为: 0 ~ 7 **************/
/***请参考文档:Silan_MEMS_手环算法说明书_V1.1.pdf**************/

/***SL_Turn_Wrist_Para[1]:设定值的范围为: 1 ~ 5 **/
/*********默认值为：3   中等灵敏度****************/
/*********设定值为：1   最低灵敏度****************/
/*********默认值为：5   最高灵敏度****************/
/*********设定值为：1(最迟钝)~5(最灵敏)***********/

/******SL_Turn_Wrist_Para[2]:水平抬手亮屏使能控制位0--1*******/
/******0：禁止水平抬手功能********/
/******1：使能水平抬手功能********/

/******SL_Turn_Wrist_Para[3]:抬手对计步复位控制0--1*******/
/******0：抬手不控制计步复位********/
/******1：抬手控制计步复位**********/

/*****************抬手亮屏状态获取函数****************/
signed char SL_Watch_Wrist_Algo(void);
/***********输入参数：无***********/
/***********返回参数情况说明*******/
/**Return:  2     备注说明:屏幕点亮后需要关闭*********/
/**Return:  1     备注说明:屏幕需要点亮***************/
/**Return:  0     备注说明:屏幕不需要点亮*************/
/**Return: -1     备注说明:未初始化或初始化失败*******/

/*****************抬手亮屏状态复位********************/
//void SL_Turn_Wrist_WorkMode_Reset(void);
/******************输入参数：无***********************/
/******************输出值参数：无*********************/

unsigned char SL_Turn_Wrist_Twice_Status(void);
/******************输入参数：无***********************/
/******************输出值参数：两次翻转检测结果*******/
/**Return:  1     备注说明:触发两次翻转动作***********/
/**Return:  0     备注说明:没有触发两次翻转动作*******/


//3-12
//1-10
//0-10
/******************睡眠参数设置********************/
void SL_Sleep_Para(unsigned char adom_time_th,unsigned char sleep_vpp_th,unsigned char sleep_time_th);
/**************************佩戴检测的时长***********************/
/******adom_time_th:0-255 min***********************************/
/******adom_time_th:未活动的时间，大于设置阈值才能认为未佩戴****/
/******adom_time_th:设置值越小，越容易出现未佩戴情况************/
/******adom_time_th:255，关闭睡眠时的佩戴检测功能***************/

/**************************睡眠中间点阈值***********************/
/******sleep_vpp_th:越小灵敏度越高，越容易睡眠状态切换**********/
/******sleep_vpp_th:越大灵敏度越低，越难睡眠状态切换************/
/******sleep_vpp_th:默认值10，不设置就是10**********************/

/**************************状态切换最小时间*********************/
/******sleep_time_th:该值越小，睡眠状态切换的所需时间就越短*****/
/******sleep_time_th:该值越大，睡眠状态切换的所需时间就越长*****/
/******sleep_time_th:默认值1，不设置就是1***********************/


/***************获取当前的睡眠状态*****************/
unsigned char SL_Sleep_GetStatus(unsigned char SL_Sys_Time);
/*******SL_Sys_Time：当前的时间，以小时为单位******/
/*******全天的输入时间范围为：0-23 ****************/
/***************输出数据范围：0-7******************/
/***************0：清醒状态************************/
/***************7：深度睡眠************************/

/***************获取当前的活动等级*****************/
unsigned char SL_Sleep_Active_Degree(unsigned char mode);
/***************mode：0 定时器0.5s中调用***********/
/***************mode：1 定时器1min中调用***********/
/***************输出数据范围：0-255****************/
/***************0：静止****************************/
/*************255：运动****************************/

unsigned char SL_Sleep_Get_Active_Degree(void);
/***************mode：0 定时器0.5s中调用***********/
/***************mode：1 定时器1min中调用***********/
/***************输出数据范围：0-255****************/
/***************0：静止****************************/
/*************255：运动****************************/

/***************获取当前的佩戴的情况***************/
unsigned char SL_Adom_GetStatus(void);
/***************0：未佩戴**************************/
/***************1：已佩戴**************************/

/***************获取当前的佩戴的情况***************/
unsigned char SL_In_Sleep_Status(void);
/***************0：out sleep**********************/
/***************1：in sleep***********************/

/**************************翻转功能************************/
bool SL_Get_Clock_Status(bool open_close);
/***********输入参数：sensor_pos***********/
/****sensor_pos:1 open  检测是否要关闭时输入 1*************/
/****sensor_pos:0 close 关闭闹铃时时    输入 0*************/
/*********************返回参数情况说明*********************/
/***********************翻转功能检测***********************/
/**Return:  1     备注说明:屏幕已翻转，关闭闹钟************/
/**Return:  0     备注说明:屏幕未翻转，不关闭闹钟**********/

unsigned char SL_Get_Direction_Status(void);
/*********************返回参数情况说明*********************/
/***********************6个方向检测************************/
/**Return:  0     过渡位置角度*****************************/
/**Return:  1     X=1G 方向成立****************************/
/**Return:  2     X=-1G 方向成立***************************/
/**Return:  3     Y=1G 方向成立****************************/
/**Return:  4     Y=-1G 方向成立***************************/
/**Return:  5     Z=1G 方向成立****************************/
/**Return:  6     Z=-1G 方向成立***************************/

/**************************摇晃功能************************/
bool SL_Get_Phone_Answer_Status(unsigned char Sway_Degree,unsigned char Sway_Num);
/***********输入参数：摇晃等级0--10  摇晃数量0--10***********************/
/***摇晃等级：设置值越小，需要摇晃的幅度越小，越容易触发接听动作*********/
/***摇晃数量：设置值越小，需要摇晃的次数越少，越容易触发接听动作*********/
/***********返回参数情况说明*******************************/
/**Return:  1     备注说明:摇晃动作成立，接听电话**********/
/**Return:  0     备注说明:摇晃动作不成立，不接听电话******/


/**************************跌倒检测初始化参数*****************************/
void SL_SC7A20_FreeFall_Init(unsigned char sl_vth,unsigned char sl_tth,unsigned short sl_max);
/****sl_vth:0-127   默认值=5*******************************/
/****sl_tth:0-127   默认值=5*******************************/
/****sl_max:0-65536 默认值=300*****************************/
/*********************返回参数情况说明*********************/


/*******************跌倒检测结果获取***********************/
bool SL_SC7A20_Get_FreeFall_Status(void);
/*********************返回参数情况说明*********************/
/****return:0   未触发跌倒状态*****************************/
/****return:1   已触发跌倒状态*****************************/


/************加测项目客户端测试***********/
/***初始化的时候调用用于判断FIFO是否正常**/
bool SL_SC7A20_FIFO_TEST(void);
/*************输入参数:无*****************/
/*************返回数据情况如下************/
/**return :1  FIFO 异常*******************/
/**return :0  FIFO 正常*******************/
/****SL_Watch_ALGO_DRV__H__*********/


/*****加测项目客户端测试 校准XY零漂*******/
bool SL_SC7A20_CAL_FUN(unsigned char *sl_fifo_num,signed char *sl_xy_cal);
/*************输入参数:2*****************************/
/***sl_fifo_num[0]:控制FIFO延时，使得FIFO长度为12****/
/***sl_xy_cal[0]:校准完成时，输出X轴的校准值,需保存**/
/***sl_xy_cal[1]:校准完成时，输出Y轴的校准值,需保存**/
/********return :1  校准完成，<150mg*****************/
/********return :0  校准失败，>150mg*****************/

/*****加测项目 校准XY时使用的延时函数****************/
extern void sl_fifo_delay(void);
/***sl_fifo_num[0]:控制FIFO延时，使得FIFO长度为12****/


/*****加测项目客户端测试 校准XY零漂**********************************/
void SL_SC7A20_CAL_WRITE(signed char sl_x_cal,signed char sl_y_cal);
/********校准后已填写，需要再掉电重启后通过本函数写入校准值**********/
/********sl_x_cal :填写X轴校准值到传感器中***************************/
/********sl_y_cal :填写Y轴校准值到传感器中***************************/

/*****加测项目客户端读取数据保存校准值*******************************/
unsigned char SL_SC7A20_MTP_READ(unsigned char *sl_cal_save_buf);
/**SC7A20 输入参数：数组首地址，要求数组长度30********/
/**SC7A20E输入参数：数组首地址，要求数组长度13********/
/**SC7A20H输入参数：数组首地址，要求数组长度29********/

/***********SC7A20返回参数情况说明********************/
/**Return:  1     备注说明:15寄存器错误***************/
/**Return:  2     备注说明:16寄存器错误***************/
/**Return:  3     备注说明:1516寄存器均错误***********/
/**Return: 30     备注说明:校准值正常，可以保存；校准值错误，需要重新写入*******/
/***********SC7A20E返回参数情况说明*******************/
/**Return:  1     备注说明:60寄存器错误***************/
/**Return: 13     备注说明:校准值正常，可以保存；校准值错误，需要重新写入*******/
/***********SC7A20H返回参数情况说明*******************/
/**Return:  1     备注说明:5F寄存器错误***************/
/**Return: 29     备注说明:校准值正常，可以保存；校准值错误，需要重新写入*******/


/*****加测项目客户端判断数据是否正常，异常时需要再次写入************/
unsigned char SL_SC7A20_MTP_WRITE(unsigned char *sl_cal_save_buf);
/**SC7A20 输入参数：数组首地址，要求数组长度30********/
/**SC7A20E输入参数：数组首地址，要求数组长度13********/
/**SC7A20H输入参数：数组首地址，要求数组长度29********/

/***********返回参数情况说明*******/
/**Return:0 备注说明:写入校准值验证失败，写入失败*****/
/**Return:1 备注说明:写入校准值验证成功，写入成功*****/


/*****使用外部抬手亮屏时，触发抬手功能后调用**********/
void SL_Wrist_Fun_Happened(void);
/******无输入参数，无输出参数，用于抑制抬手计步*******/

/*****初始化所有算法参数，需要在其他函数调用前操作******/
void SL_Watch_All_Para_Init(void);
/******无输入参数，无输出参数，用于中科蓝汛平台*********/

/*****捏手动作识别算法参数初始化************************/
void SL_Pinch_Recognition_Init(unsigned char vth1,unsigned char vth2,unsigned char vth3,unsigned char tth1,unsigned char tth2);
/****vth1：静止阈值***********tth1：静止时间时间阈值****/
/****vth2：捏手动作阈值1******tth2：捏手完成时间阈值****/
/****vth3：捏手动作阈值2********************************/
/****输入参数，无输出参数*******************************/
/****SC7A20E推荐参数：10,20,100,10,60*******************/
/****SC7A20H推荐参数：5,10,100,10,60********************/

/*****捏收动作识别算法函数******************************/
unsigned char SL_Pinch_Recognition_Algo(unsigned char *fifo_len,signed short *fifo_buf);
/*****fifo_len[0]： 输出数据长度***********************/
/*****fifo_buf[0~fifo_len[0]]： 输出数据数组，数据长度为第一个参数********/
/****无输入参数，输出调试数据*********************************************/
/****return 0:无捏手；return 1:有捏手*************************************/

void sl_var_init(void);
void sl_data_update(void);
void sl_var_clr(void);
void gsensor_use_info_set(uint8_t sex, uint8_t age, uint8_t weight, uint8_t height, bool custom);

void sc7a20_wrist_set(char wrist);
char sc7a20_wrist_get(void);
char sc7a20_wkup_get(void);
void sc7a20_sway_set(bool sway);
bool sc7a20_sway_get(void);
bool sc7a20_sway_status_get(void);
UINT sc7a20_cur_steps_get(void);
UINT sc7a20_cur_kcal_get(void);
UINT sc7a20_cur_distance_get(void);

#endif //(SENSOR_STEP_SEL == SENSOR_STEP_SC7A20)

#endif //SL_WATCH_APPLICATION__H__




///////////////old
// /*
// Copyright (c) 2017 Silan MEMS. All Rights Reserved.
// */

// #ifndef SL_WATCH_APPLICATION__H__
// #define SL_WATCH_APPLICATION__H__

// #include "include.h"

// #if  (SENSOR_STEP_SEL == SENSOR_STEP_SC7A20)

// #define SC7A20_WRITE_ADDR(ADDR)      ((ADDR) << 1)
// #define SC7A20_READ_ADDR_UPDATE(ADDR)   ((ADDR) << 1 | 1)
// #define SC7A20_READ_ADDR(ADDR)       ((ADDR) << 1 | 1) << 8 | ((ADDR) << 1)

// #define SL_Sensor_Algo_Release_Enable 0x01
// //0x00: for debug
// //0x01: release version

// /***使用驱动前请根据实际接线情况配置******/
// /**SC7A20的SDO 脚接地：  0****************/
// /**SC7A20的SDO 脚接电源：1****************/
// #define SL_SC7A20_SDO_VDD_GND            0
// /*****************************************/

// /***使用驱动前请根据实际IIC情况进行配置***/
// /**SC7A20的IIC 接口地址类型 7bits：  0****/
// /**SC7A20的IIC 接口地址类型 8bits：  1****/
// #define SL_SC7A20_IIC_7BITS_8BITS        0
// /*****************************************/

// #if SL_SC7A20_SDO_VDD_GND==0
// #define SL_SC7A20_IIC_7BITS_ADDR        0x18
// #define SL_SC7A20_IIC_8BITS_WRITE_ADDR  0x30
// #define SL_SC7A20_IIC_8BITS_READ_ADDR   0x31
// #else
// #define SL_SC7A20_IIC_7BITS_ADDR        0x19
// #define SL_SC7A20_IIC_8BITS_WRITE_ADDR  0x32
// #define SL_SC7A20_IIC_8BITS_READ_ADDR   0x33
// #endif

// #if SL_SC7A20_IIC_7BITS_8BITS==0
// #define SL_SC7A20_IIC_ADDRESS        SL_SC7A20_IIC_7BITS_ADDR
// #else
// #define SL_SC7A20_IIC_WRITE_ADDRESS  SL_SC7A20_IIC_8BITS_WRITE_ADDR
// #define SL_SC7A20_IIC_READ_ADDRESS   SL_SC7A20_IIC_8BITS_READ_ADDR
// #endif

// #define SL_SC7A20_CHIP_ID_ADDR       (unsigned char)0x0F
// #define SL_SC7A20_CHIP_ID_VALUE      (unsigned char)0x11
// #define SL_SC7A20_VERSION_ADDR       (unsigned char)0x70
// #define SL_SC7A20_VERSION_VALUE      (unsigned char)0x11
// #define SL_SC7A20E_VERSION_VALUE     (unsigned char)0x26
// #define SL_SC7A20H_VERSION_VALUE     (unsigned char)0x28

// // extern  signed int  SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_SWAY_ALGO(void);
// extern  signed char SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_SWAY_INIT(void);
// extern  signed int  SL_SC7A20_PEDO_KCAL_WRIST_SLEEP_INT_SWAY_ALGO(void);
// extern  unsigned char SL_MCU_SLEEP_ALGO_FUNCTION(void);
// // extern  void sl_update_sleep_sys_hour(unsigned char hour);

// /********客户需要进行的IIC接口封包函数****************/
// extern unsigned char SL_SC7A20_I2cAddr_Read(unsigned char iic_addr, unsigned char reg, unsigned char len, unsigned char *buf);
// /***SL_SC7A20_I2cAddr_Read 函数中， iic_addr:Sensor's i2c address Reg：寄存器地址  len:读取数据长度，buf:存储数据首地址（指针）***/
// /***SL_SC7A20_I2cAddr_Read 函数 是可以进行单次读或多次连续读取的函数**************************************************************/

// /********客户用于对传感器的IIC地址查找函数************************/
// unsigned char SL_ACC_Find_I2C_Address(void);
// /****返回值7位地址：0x18-0x1F   通讯正常，按照该地址进行应用******/
// /****返回值7位地址：0x00        通讯异常，检测芯片或焊接问题******/

// /********客户需要进行的IIC&SPI接口封包函数************************/
// extern unsigned char SL_SC7A20_I2c_Spi_Write(bool sl_spi_iic,unsigned char reg, unsigned char dat);
// extern unsigned char SL_SC7A20_I2c_Spi_Read(bool sl_spi_iic,unsigned char reg, unsigned char len, unsigned char *buf);
// /**SL_SC7A20_I2c_Spi_Write 函数中， sl_spi_iic:0=spi  1=i2c  Reg：寄存器地址   dat：寄存器的配置值*******************/
// /**SL_SC7A20_I2c_Spi_Write 函数 是一个单次写的函数*******************************************************************/
// /***SL_SC7A20_I2c_Spi_Read 函数中， sl_spi_iic:0=spi  1=i2c Reg 同上，len:读取数据长度，buf:存储数据首地址（指针）***/
// /***SL_SC7A20_I2c_Spi_Read 函数 是可以进行单次读或多次连续读取的函数*************************************************/

// /*************驱动初始化函数**************/
// signed char SL_SC7A20_Driver_Init(bool Sl_spi_iic_init,unsigned char Sl_pull_up_mode,bool sl_addr_auto);
// /***输入参数:1,Sl_spi_iic_init:0-1***2,PULL_UP_MODE:0x00 0x08 0x04 0x0c********/
// /****Sl_spi_iic_init=0：SPI MODE, Sl_pull_up_mode config failed****************/
// /****Sl_spi_iic_init=1：IIC MODE***********************************************/
// /****Sl_pull_up_mode=0x00: SDO  I2C  pull up***********************************/
// /****Sl_pull_up_mode=0x08: I2C  pull up and  SDO  open drain*******************/
// /****Sl_pull_up_mode=0x04: SDO  pull up and  I2C  open drain*******************/
// /****Sl_pull_up_mode=0x0C: SDO  I2C  open drain********************************/
// /****sl_addr_auto=0: 地址不自增，仅对SC7A20E有效，应用于单地址读取FIFO数据*****/
// /****sl_addr_auto=1: 地址自增，仅对SC7A20E有效，应用于多地址读取FIFO数据*******/
// /****SDO脚接地，推荐关闭SDO内部上拉电阻****************************************/
// /****SPI通讯，推荐关闭SDA，SCL内部上拉电阻，SDO内部上拉电阻会自动关闭**********/
// /****SC7A20E/SC7A20ET，推荐sl_addr_auto=0，单地址读取可以节约I2C通讯时的功耗***/

// /*************返回数据情况如下*****************/
// /**return : 0x11 SC7A20表示CHIP ID 正常********/
// /**return : 0x26 SC7A20E表示CHIP ID 正常*******/
// /**return : 0x28 SC7A20H表示CHIP ID 正常*******/
// /**return : 0         表示读取异常*************/
// /**return :-1;        SPI 通信问题*************/
// /**return :-2;        IIC 通信问题*************/
// /**return :-3;        连续读取 通信问题********/

// /***************执行算法前需要读取FIFO数据*****/
// /***************FIFO数据读取后，FIFO会清空*****/
// /***************所以FIFO只能定时读取一次*******/
// unsigned char SL_SC7A20_Read_FIFO(void);
// /**return : FIFO_LEN    表示数组长度***********/


// /****说明:该函数需要定时执行,从而保证算法执行到位**/
// /***************执行算法获取计步结果***************/
// unsigned int SL_Watch_Kcal_Pedo_Algo(bool sl_music_motor_en);
// /***sl_music_motor_en=0: 马达电机和音乐功能未打开**/
// /***sl_music_motor_en=1: 马达电机和音乐功能已打开**/
// /**************获取当天的当前计步值****************/
// /*************输出数据为：计步值(步)***************/

// /***************获取三轴原始数据***************/
// unsigned char SL_SC7A20_GET_FIFO_Buf(signed short *sl_x_buf,signed short *sl_y_buf,signed short *sl_z_buf,bool filter_en);
// /****************执行算法后执行该命令**********/
// /**x_buf  y_buf  z_buf : 长度32的数组首地址****/
// /**filter_en：0 低通滤波禁止 1：低通滤波使能***/
// /****************返回数据情况如下**************/
// /**return : FIFO_LEN    表示数组长度***********/

// /***************获取三轴实时数据***************/
// void SL_SC7A20_GET_DATA(signed short *sl_x_dat,signed short *sl_y_dat,signed short *sl_z_dat);
// /***SC7A20/SC7A20T:    获取上一次读取FIFO的最后一组数据*********/
// /***SC7A20E/SC7A20ET:  获取实时数据，且不对FIFO数据产生影响*****/

// /******************复位计步值************************/
// void SL_Pedo_Kcal_ResetStepCount(void);
// /**********输入数据为：无******输出数据为：无********/
// /*使用方法: 系统时间到第二天时，调用该函数清除计步值*/

// /*******************计步状态复位**********************/
// void SL_Pedo_WorkMode_Reset(void);
// /******************输入参数：无***********************/
// /******************输出值参数：无*********************/

// /******************升级后，设置计步值,距离,热量************************/
// /******************升级后，请在初始化函数后，增加该函数****************/
// void SL_Pedo_StepCount_Set(unsigned int sl_pedo_value,unsigned int sl_dis_value,unsigned int sl_kcal_value);
// /**********输入数据为：sl_pedo_value  计步值*****/
// /**********输入数据为：sl_dis_value   距离值*****/
// /**********输入数据为：sl_kcal_value  热量值*****/

// /******************计步灵敏度设置********************/
// void SL_PEDO_TH_SET(unsigned char sl_pedo_amp,unsigned char sl_pedo_th,unsigned char sl_pedo_weak,unsigned char sl_zcr_lel,unsigned char sl_scope_lel);
// /******sl_pedo_amp>4&&sl_pedo_amp<201**************************/
// /******sl_pedo_amp:越小灵敏度越高，越容易计步******************/
// /******sl_pedo_amp:越大灵敏度越高，越难计步********************/
// /******sl_pedo_amp:默认值26，不设置就是26**********************/

// /******sl_pedo_th>5&&sl_pedo_th<50*****************************/
// /******sl_pedo_th:越小灵敏度越高，越容易计步*******************/
// /******sl_pedo_th:越大灵敏度越高，越难计步*********************/
// /******sl_pedo_th:默认值10，不设置就是10***********************/

// /******sl_pedo_weak>=0&&sl_pedo_weak<6*************************/
// /******sl_pedo_weak:0,不打开轻微走路计步功能*********************/
// /******sl_pedo_weak:1,打开轻微走路计步功能***********************/
// /******sl_pedo_weak:2,打开轻微走路计步功能***********************/
// /******sl_pedo_weak:3,打开轻微走路计步功能***********************/
// /******sl_pedo_weak:4,打开轻微走路计步功能***********************/
// /******sl_pedo_weak:5,打开轻微走路计步功能***********************/
// /******sl_pedo_weak:默认值0,设置的值越大，检测计步的越灵敏*******/

// /*****sl_zcr_lel>=0&&sl_zcr_lel<=255***************************/
// /*****sl_zcr_lel:默认值=20,设置的值越小，越容易屏蔽喇叭震动****/
// /*****一定时间内的过零率计算***********************************/

// /*****sl_scope_lel>=0&&sl_scope_lel<=255***********************/
// /*****整体数据幅度阈值*****************************************/


// /*******计步主轴设置****************/
// void SL_PEDO_SET_AXIS(unsigned char sl_xyz);
// /***sl_xyz:0  x轴*******************/
// /***sl_xyz:1  y轴*******************/
// /***sl_xyz:2  z轴*******************/
// /***sl_xyz:3  算法决定**************/

// /***********关闭IIC设备**************/
// /***********Power down 函数**********/
// /********不使用该设备情况下**********/
// /****如需重启，使用驱动初始化函数****/
// bool  SL_SC7A20_Power_Down(void);
// /*************输入参数:无************/
// /**********返回参数情况说明**********/
// /**return  1: Power Down Success*****/
// /**return  0: Power Down Fail********/




// /*************初始化个人参数*************/
// /**参数初始化，用于热量，距离计算********/
// void SL_Pedo_Person_Inf_Init(unsigned char *Person_Inf_Init);
// /*********输入指针参数分别是:身高 体重 年龄 性别***举例:178,60,26 1*********/
// /**身高范围:  30cm ~ 250cm  ***********/
// /**体重范围:  10Kg ~ 200Kg  ***********/
// /**年龄范围:  3岁  ~ 150岁  ***********/
// /**性别范围:  0 ~ 1    0:女 1:男   ****/

// /*********************获取运动状态值**********************/
// unsigned char SL_Pedo_GetMotion_Status(void);
// /**********输入数据为：无*********************************/
// /**********输出数据为：0 ~ 3 *****************************/
// /**输出数据为：0   *静止或静坐**********/
// /**输出数据为：1   *慢走或散步**********/
// /**输出数据为：2   *正常走路************/
// /**输出数据为：3   *跑步或剧烈运动******/

// /**************获取截止当前当天的行走距离*****************/
// unsigned int SL_Pedo_Step_Get_Distance(void);
// /*******************输入数据为：无************************/
// /*******************输出数据为：当天行走距离 *************/
// /*******************单位:       分米(dm)******************/

// /**************获取截止当前当天的热量消耗*****************/
// unsigned int SL_Pedo_Step_Get_KCal(void);
// /*******************输入数据为：无************************/
// /*******************输出数据为：当天热量消耗值 ***********/
// /*********单位: 大卡     1个单位=0.1大卡******************/

// /**************获取最近一段时间的走路平均幅度*************/
// unsigned short SL_Pedo_Step_Get_Avg_Amp(void);
// /********************输入数据为：无***********************/
// /***********************1LSB≈XXXmg************************/

// /***********************获取当前走路平均步频**************/
// unsigned char SL_Pedo_Step_Get_Step_Per_Min(void);
// /********************输入数据为：无***********************/
// /********************输出数据为：XXX步/分钟 **************/

// /***********************获取当前的运动等级****************/
// unsigned char SL_Pedo_Step_Get_Motion_Degree(void);
// /********************输入数据为：无***********************/
// /********************输出数据为：0-25 ********************/


// /**********抬手亮屏算法**********/

// /*****************抬手亮屏算法初始化函数****************/
// void SL_Turn_Wrist_Init(unsigned char *SL_Turn_Wrist_Para);
// /************输入参数：*************/
// /******SL_Turn_Wrist_Para[0]:加速度计贴片位置设置  0--7********/
// /******SL_Turn_Wrist_Para[1]:抬手亮屏灵敏度设置    1--5********/
// /******SL_Turn_Wrist_Para[2]:水平抬手亮屏使能控制位0--1********/

// /*************三轴加速度计贴片位置设置*************************/
// /***SL_Turn_Wrist_Para[0]：设定值的范围为: 0 ~ 7 **************/
// /***请参考文档:Silan_MEMS_手环算法说明书_V1.1.pdf**************/

// /***SL_Turn_Wrist_Para[1]:设定值的范围为: 1 ~ 5 **/
// /*********默认值为：3   中等灵敏度****************/
// /*********设定值为：1   最低灵敏度****************/
// /*********默认值为：5   最高灵敏度****************/
// /*********设定值为：1(最迟钝)~5(最灵敏)***********/

// /******SL_Turn_Wrist_Para[2]:水平抬手亮屏使能控制位0--1*******/
// /******0：禁止水平抬手功能********/
// /******1：使能水平抬手功能********/

// /******SL_Turn_Wrist_Para[3]:抬手对计步复位控制0--1*******/
// /******0：抬手不控制计步复位********/
// /******1：抬手控制计步复位**********/

// /*****************抬手亮屏状态获取函数****************/
// signed char SL_Watch_Wrist_Algo(void);
// /***********输入参数：无***********/
// /***********返回参数情况说明*******/
// /**Return:  2     备注说明:屏幕点亮后需要关闭*********/
// /**Return:  1     备注说明:屏幕需要点亮***************/
// /**Return:  0     备注说明:屏幕不需要点亮*************/
// /**Return: -1     备注说明:未初始化或初始化失败*******/

// /*****************抬手亮屏状态复位********************/
// //void SL_Turn_Wrist_WorkMode_Reset(void);
// /******************输入参数：无***********************/
// /******************输出值参数：无*********************/


// //3-12
// //1-10
// //0-10
// /******************睡眠参数设置********************/
// void SL_Sleep_Para(unsigned char adom_time_th,unsigned char sleep_vpp_th,unsigned char sleep_time_th);
// /**************************佩戴检测的时长***********************/
// /******adom_time_th:0-255 min***********************************/
// /******adom_time_th:未活动的时间，大于设置阈值才能认为未佩戴****/
// /******adom_time_th:设置值越小，越容易出现未佩戴情况************/
// /******adom_time_th:255，关闭睡眠时的佩戴检测功能***************/

// /**************************睡眠中间点阈值***********************/
// /******sleep_vpp_th:越小灵敏度越高，越容易睡眠状态切换**********/
// /******sleep_vpp_th:越大灵敏度越低，越难睡眠状态切换************/
// /******sleep_vpp_th:默认值10，不设置就是10**********************/

// /**************************状态切换最小时间*********************/
// /******sleep_time_th:该值越小，睡眠状态切换的所需时间就越短*****/
// /******sleep_time_th:该值越大，睡眠状态切换的所需时间就越长*****/
// /******sleep_time_th:默认值1，不设置就是1***********************/


// /***************获取当前的睡眠状态*****************/
// unsigned char SL_Sleep_GetStatus(unsigned char SL_Sys_Time);
// /*******SL_Sys_Time：当前的时间，以小时为单位******/
// /*******全天的输入时间范围为：0-23 ****************/
// /***************输出数据范围：0-7******************/
// /***************0：清醒状态************************/
// /***************7：深度睡眠************************/

// /***************获取当前的活动等级*****************/
// unsigned char SL_Sleep_Active_Degree(unsigned char mode);
// /***************mode：0 定时器0.5s中调用***********/
// /***************mode：1 定时器1min中调用***********/
// /***************输出数据范围：0-255****************/
// /***************0：静止****************************/
// /*************255：运动****************************/

// unsigned char SL_Sleep_Get_Active_Degree(void);
// /***************mode：0 定时器0.5s中调用***********/
// /***************mode：1 定时器1min中调用***********/
// /***************输出数据范围：0-255****************/
// /***************0：静止****************************/
// /*************255：运动****************************/

// /***************获取当前的佩戴的情况***************/
// unsigned char SL_Adom_GetStatus(void);
// /***************0：未佩戴**************************/
// /***************1：已佩戴**************************/

// /***************获取当前的佩戴的情况***************/
// unsigned char SL_In_Sleep_Status(void);
// /***************0：out sleep**********************/
// /***************1：in sleep***********************/



// /*************中断配置参数初始化**********/
// void SL_Sc7a20_Int_Config(unsigned char *para);
// /***输入数组参数分别是: 中断引脚选择  中断时的电平高低  中断幅度阈值 中断时间阈值****/
// /****para[0]****中断引脚选择: 1(中断1 PIN5)  2(中断2 PIN6) **************************/
// /****para[1]****进入中断时的电平: 0(中断触发时为低电平) 1(中断触发时为高电平)********/
// /****para[2]****中断判断幅度阈值: N=(1~127)  不同量程其含义不同**********************/
// /****para[3]****中断判断时间阈值: N=(1~127)  N*1/ODR 单位s***************************/

// /*************获取活动等级*****************/
// /*获取活动等级，用于判断是否打开传感器中断*/
// bool SL_SC7A20_Action_Degree(void);

// /***********SC7A20 中断功能打开************/
// /*当主控需要进入休眠模式时，需要调用该函数*/
// void SL_MCU_SLEEP_OPEN_SC7A20_INT(void);

// /***********SC7A20 中断功能关闭************/
// /*当主控唤醒后，为了禁止中断触发，需要关闭*/
// void SL_MCU_WAKE_CLOSE_SC7A20_INT(void);


// /*******close sc7a20 0.5s timer********/
// /**用于自定义SC7A20算法定时器关闭函数**/
// extern void SL_Close_Sc7a20_Timer(void);

// /*******open sc7a20 0.5s timer*********/
// /**用于自定义SC7A20算法定时器打开函数**/
// extern void SL_Open_Sc7a20_Timer(void);

// /**************************翻转功能************************/
// bool SL_Get_Clock_Status(bool open_close);
// /***********输入参数：sensor_pos***********/
// /****sensor_pos:1 open  检测是否要关闭时输入 1*************/
// /****sensor_pos:0 close 关闭闹铃时时    输入 0*************/
// /*********************返回参数情况说明*********************/
// /***********************翻转功能检测***********************/
// /**Return:  1     备注说明:屏幕已翻转，关闭闹钟************/
// /**Return:  0     备注说明:屏幕未翻转，不关闭闹钟**********/

// unsigned char SL_Get_Direction_Status(void);
// /*********************返回参数情况说明*********************/
// /***********************6个方向检测************************/
// /**Return:  0     过渡位置角度*****************************/
// /**Return:  1     X=1G 方向成立****************************/
// /**Return:  2     X=-1G 方向成立***************************/
// /**Return:  3     Y=1G 方向成立****************************/
// /**Return:  4     Y=-1G 方向成立***************************/
// /**Return:  5     Z=1G 方向成立****************************/
// /**Return:  6     Z=-1G 方向成立***************************/

// /**************************摇晃功能************************/
// bool SL_Get_Phone_Answer_Status(unsigned char Sway_Degree,unsigned char Sway_Num);
// /***********输入参数：摇晃等级0--10  摇晃数量0--10***********************/
// /***摇晃等级：设置值越小，需要摇晃的幅度越小，越容易触发接听动作*********/
// /***摇晃数量：设置值越小，需要摇晃的次数越少，越容易触发接听动作*********/
// /***********返回参数情况说明*******************************/
// /**Return:  1     备注说明:摇晃动作成立，接听电话**********/
// /**Return:  0     备注说明:摇晃动作不成立，不接听电话******/


// /************加测项目客户端测试***********/
// /***初始化的时候调用用于判断FIFO是否正常**/
// bool SL_SC7A20_FIFO_TEST(void);
// /*************输入参数:无*****************/
// /*************返回数据情况如下************/
// /**return :1  FIFO 异常*******************/
// /**return :0  FIFO 正常*******************/
// /****SL_Watch_ALGO_DRV__H__*********/

// #endif //(SENSOR_STEP_SEL == SENSOR_STEP_SC7A20)


// /*****加测项目客户端测试 校准XY零漂*******/
// bool SL_SC7A20_CAL_FUN(unsigned char *sl_fifo_num,signed char *sl_xy_cal);
// /*************输入参数:2*****************************/
// /***sl_fifo_num[0]:控制FIFO延时，使得FIFO长度为12****/
// /***sl_xy_cal[0]:校准完成时，输出X轴的校准值,需保存**/
// /***sl_xy_cal[1]:校准完成时，输出Y轴的校准值,需保存**/
// /********return :1  校准完成，<150mg*****************/
// /********return :0  校准失败，>150mg*****************/

// /*****加测项目 校准XY时使用的延时函数****************/
// extern void sl_fifo_delay(void);
// /***sl_fifo_num[0]:控制FIFO延时，使得FIFO长度为12****/


// /*****加测项目客户端测试 校准XY零漂**********************************/
// void SL_SC7A20_CAL_WRITE(signed char sl_x_cal,signed char sl_y_cal);
// /********校准后已填写，需要再掉电重启后通过本函数写入校准值**********/
// /********sl_x_cal :填写X轴校准值到传感器中***************************/
// /********sl_y_cal :填写Y轴校准值到传感器中***************************/

// void sl_var_init(void);
// void sl_data_update(void);
// void sl_var_clr(void);
// void gsensor_use_info_set(uint8_t sex, uint8_t age, uint8_t weight, uint8_t height, bool custom);

// void sc7a20_wrist_set(char wrist);
// char sc7a20_wrist_get(void);
// char sc7a20_wkup_get(void);
// void sc7a20_sway_set(bool sway);
// bool sc7a20_sway_get(void);
// bool sc7a20_sway_status_get(void);
// UINT sc7a20_cur_steps_get(void);
// UINT sc7a20_cur_kcal_get(void);
// UINT sc7a20_cur_distance_get(void);

// #endif //SL_WATCH_APPLICATION__H__
